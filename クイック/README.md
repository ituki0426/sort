

# 考え方

クイックソートはデータ全体を集合に分割しながら、集合単体でソートを行うアルゴリズム。

クイックソートでは、まずデータ全体の集合を以下の二つの集合に分割します。

・闘値以上のデータの集合

・闘値以下のデータの集合

この闘値をどこの値にするかで、軸が決まる。以下の場合は左端を軸としている。

![image](https://user-images.githubusercontent.com/82156802/177675067-9558013d-65f2-473d-95fb-465307d58f1b.png)

このように分割すれば、前者の全データは後者の全データよりも小さい。

つまり、集合単位でみるとソートできている。


![image](https://user-images.githubusercontent.com/82156802/177675203-71260a58-250e-403b-b0fb-c4d1d4e16b83.png)

同様に分割すれば、さらに小さな集合が集合の単位でソートできることになり、これを繰り返せば、最終的には各集合に1つのデータしか含まれない。

![image](https://user-images.githubusercontent.com/82156802/177675278-2b405703-2eaa-4cae-813d-bc9940ce7522.png)

![image](https://user-images.githubusercontent.com/82156802/177682270-fe002e30-03e7-4a57-99ec-ac3f0fb605dd.png)


```c
void quick(int a[],int left,int right){
	int s,t,i,j;
	if(left<right){
		s=a[left];
		//+1する理由はのちのコードでwhile(a[--j]>s)とするからである。
		//--jなので先に1を引く。そのためj=rightとしてしまうと一番右の値が読み込まれない。
		j=right+1;
		//一番左は軸となる値なので、読み込まないため、+1をしない。
		i=left;
		while (1){
			while (a[++i]<s);//左から検索。軸より小さい値があれば終了
			while (a[--i]>s);//右から検索。軸より大きい値があれば終了
			if(i>=j) break;
			t=a[i];
			a[i]=a[j];
			a[j]=t;
		}
		//この時jの添え字は左側のグループの一番右側の値の添え字
		//そして、軸となった値とj番目にある値を入れ替える。
		//そして、j番目の値はソートが完了する。
		quick(a,left,j-1);
		quick(a,j+1,right);
		//j番目の値はソートが完了しているため、以下の再帰呼び出しではj番目の値を避ける。
	}
}
```
# サンプルコード

## 1.降順にソートするプログラム

## 2.右端を軸として昇順にソートするプログラム

